"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var wallet_exports = {};
__export(wallet_exports, {
  STASHED_WALLET_NAME: () => STASHED_WALLET_NAME,
  StashedWallet: () => StashedWallet,
  registerStashedWallet: () => registerStashedWallet
});
module.exports = __toCommonJS(wallet_exports);
var import_transactions = require("@mysten/sui/transactions");
var import_utils = require("@mysten/sui/utils");
var import_wallet_standard = require("@mysten/wallet-standard");
var import_mitt = __toESM(require("mitt"));
var import_channel = require("./channel/index.js");
var _events, _accounts, _origin, _name, _network, _signTransactionBlock, _signTransaction, _signPersonalMessage, _on, _StashedWallet_instances, setAccount_fn, _connect, _disconnect;
const STASHED_RECENT_ADDRESS_KEY = "stashed:recentAddress";
const STASHED_WALLET_NAME = "Stashed";
class StashedWallet {
  constructor({
    name,
    network,
    address,
    origin = import_channel.DEFAULT_STASHED_ORIGIN
  }) {
    __privateAdd(this, _StashedWallet_instances);
    __privateAdd(this, _events);
    __privateAdd(this, _accounts);
    __privateAdd(this, _origin);
    __privateAdd(this, _name);
    __privateAdd(this, _network);
    __privateAdd(this, _signTransactionBlock, async ({ transactionBlock, account }) => {
      transactionBlock.setSenderIfNotSet(account.address);
      const data = transactionBlock.serialize();
      const popup = new import_channel.StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin),
        network: __privateGet(this, _network)
      });
      const response = await popup.send({
        type: "sign-transaction-block",
        data,
        address: account.address
      });
      return {
        transactionBlockBytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _signTransaction, async ({ transaction, account }) => {
      const popup = new import_channel.StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin),
        network: __privateGet(this, _network)
      });
      const tx = import_transactions.Transaction.from(await transaction.toJSON());
      tx.setSenderIfNotSet(account.address);
      const data = tx.serialize();
      const response = await popup.send({
        type: "sign-transaction-block",
        data,
        address: account.address
      });
      return {
        bytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _signPersonalMessage, async ({ message, account }) => {
      const popup = new import_channel.StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin),
        network: __privateGet(this, _network)
      });
      const bytes = (0, import_utils.toBase64)(message);
      const response = await popup.send({
        type: "sign-personal-message",
        bytes,
        address: account.address
      });
      return {
        bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _on, (event, listener) => {
      __privateGet(this, _events).on(event, listener);
      return () => __privateGet(this, _events).off(event, listener);
    });
    __privateAdd(this, _connect, async (input) => {
      if (input?.silent) {
        const address = localStorage.getItem(STASHED_RECENT_ADDRESS_KEY);
        if (address) {
          __privateMethod(this, _StashedWallet_instances, setAccount_fn).call(this, address);
        }
        return { accounts: this.accounts };
      }
      const popup = new import_channel.StashedPopup({
        name: __privateGet(this, _name),
        origin: __privateGet(this, _origin),
        network: __privateGet(this, _network)
      });
      const response = await popup.send({
        type: "connect"
      });
      if (!("address" in response)) {
        throw new Error("Unexpected response");
      }
      __privateMethod(this, _StashedWallet_instances, setAccount_fn).call(this, response.address);
      return { accounts: this.accounts };
    });
    __privateAdd(this, _disconnect, async () => {
      localStorage.removeItem(STASHED_RECENT_ADDRESS_KEY);
      __privateMethod(this, _StashedWallet_instances, setAccount_fn).call(this);
    });
    __privateSet(this, _accounts, []);
    __privateSet(this, _events, (0, import_mitt.default)());
    __privateSet(this, _origin, origin);
    __privateSet(this, _name, name);
    __privateSet(this, _network, network);
    if (address) {
      __privateMethod(this, _StashedWallet_instances, setAccount_fn).call(this, address);
    }
  }
  get name() {
    return STASHED_WALLET_NAME;
  }
  get icon() {
    return "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1NiIgaGVpZ2h0PSI1NiIgZmlsbD0ibm9uZSI+PHJlY3Qgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiB4PSIxIiB5PSIxIiBmaWxsPSIjNTE5REU5IiByeD0iMjciLz48cmVjdCB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHg9IjEiIHk9IjEiIHN0cm9rZT0iIzAwMCIgc3Ryb2tlLXdpZHRoPSIyIiByeD0iMjciLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTguMzUzIDM1LjA2NGMuOTIxIDMuNDM4IDQuMzYzIDYuNTUxIDExLjQ4MyA0LjY0NCA2Ljc5NC0xLjgyMSAxMS4wNTItNy40MSA5Ljk0OC0xMS41My0uMzgxLTEuNDIzLTEuNTMtMi4zODctMy4zLTIuMjNsLTE1LjgzMiAxLjMyYy0uOTk3LjA3Ni0xLjQ1NC0uMDg4LTEuNzE4LS43MTYtLjI1Ni0uNTk5LS4xMS0xLjI0MSAxLjA5NC0xLjg1bDEyLjA0OC02LjE4M2MuOTI0LS40NyAxLjUzOS0uNjY2IDIuMTAxLS40NjguMzUyLjEyOC41ODQuNjM4LjM3MSAxLjI2N2wtLjc4MSAyLjMwNmMtLjk1OSAyLjgzIDEuMDk0IDMuNDg4IDIuMjUgMy4xNzggMS43NTEtLjQ2OSAyLjE2My0yLjEzNiAxLjU5OS00LjI0LTEuNDMtNS4zMzctNy4wOS02LjE3LTEyLjIyMy00Ljc5Ni01LjIyMiAxLjQtOS43NDggNS42My04LjM2NiAxMC43ODkuMzI1IDEuMjE1IDEuNDQ0IDIuMTg2IDIuNzQgMi4xNTdsMS45NzgtLjAwNWMuNDA3LS4wMS4yNi4wMjQgMS4wNDYtLjA0MS43ODQtLjA2NSAyLjg4LS4zMjMgMi44OC0uMzIzbDEwLjI4Ni0xLjE2NC4yNjUtLjAzOGMuNjAyLS4xMDMgMS4wNTYuMDUzIDEuNDQuNzE1LjU3Ni45OTEtLjMwMiAxLjczOC0xLjM1MiAyLjYzM2wtLjA4NS4wNzItOS4wNDEgNy43OTJjLTEuNTUgMS4zMzctMi42MzkuODM0LTMuMDItLjU4OWwtMS4zNS01LjA0Yy0uMzM0LTEuMjQ0LTEuNTUtMi4yMjEtMi45NzQtMS44NC0xLjc4LjQ3Ny0xLjkyNCAyLjU1LTEuNDg3IDQuMThaIi8+PC9zdmc+Cg==";
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return [import_wallet_standard.SUI_MAINNET_CHAIN];
  }
  get accounts() {
    return __privateGet(this, _accounts);
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: __privateGet(this, _connect)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: __privateGet(this, _disconnect)
      },
      "standard:events": {
        version: "1.0.0",
        on: __privateGet(this, _on)
      },
      "sui:signTransactionBlock": {
        version: "1.0.0",
        signTransactionBlock: __privateGet(this, _signTransactionBlock)
      },
      "sui:signTransaction": {
        version: "2.0.0",
        signTransaction: __privateGet(this, _signTransaction)
      },
      "sui:signPersonalMessage": {
        version: "1.0.0",
        signPersonalMessage: __privateGet(this, _signPersonalMessage)
      }
    };
  }
}
_events = new WeakMap();
_accounts = new WeakMap();
_origin = new WeakMap();
_name = new WeakMap();
_network = new WeakMap();
_signTransactionBlock = new WeakMap();
_signTransaction = new WeakMap();
_signPersonalMessage = new WeakMap();
_on = new WeakMap();
_StashedWallet_instances = new WeakSet();
setAccount_fn = function(address) {
  if (address) {
    __privateSet(this, _accounts, [
      new import_wallet_standard.ReadonlyWalletAccount({
        address,
        chains: [import_wallet_standard.SUI_MAINNET_CHAIN],
        features: ["sui:signTransactionBlock", "sui:signPersonalMessage"],
        // NOTE: Stashed doesn't support getting public keys, and zkLogin accounts don't have meaningful public keys anyway
        publicKey: new Uint8Array()
      })
    ]);
    localStorage.setItem(STASHED_RECENT_ADDRESS_KEY, address);
  } else {
    __privateSet(this, _accounts, []);
  }
  __privateGet(this, _events).emit("change", { accounts: this.accounts });
};
_connect = new WeakMap();
_disconnect = new WeakMap();
function registerStashedWallet(name, {
  origin,
  network = "mainnet"
} = {}) {
  const wallets = (0, import_wallet_standard.getWallets)();
  let addressFromRedirect = null;
  try {
    const params = new URLSearchParams(window.location.search);
    addressFromRedirect = params.get("stashed_address") || params.get("zksend_address");
  } catch {
  }
  const wallet = new StashedWallet({
    name,
    network,
    origin,
    address: addressFromRedirect
  });
  const unregister = wallets.register(wallet);
  return {
    wallet,
    unregister,
    addressFromRedirect
  };
}
//# sourceMappingURL=index.js.map

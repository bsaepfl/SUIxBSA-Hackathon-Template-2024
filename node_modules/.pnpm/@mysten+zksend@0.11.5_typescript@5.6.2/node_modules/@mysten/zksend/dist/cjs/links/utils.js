"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  getAssetsFromTransaction: () => getAssetsFromTransaction,
  isClaimTransaction: () => isClaimTransaction,
  isOwner: () => isOwner,
  ownedAfterChange: () => ownedAfterChange
});
module.exports = __toCommonJS(utils_exports);
var import_utils = require("@mysten/sui/utils");
function isClaimTransaction(tx, options) {
  let transfers = 0;
  for (const command of tx.getData().commands) {
    switch (command.$kind) {
      case "TransferObjects":
        if (!command.TransferObjects.objects.every(
          (o) => o.$kind === "Result" || o.$kind === "NestedResult"
        )) {
          return false;
        }
        transfers++;
        break;
      case "MoveCall":
        if (command.MoveCall.package !== options.packageId) {
          return false;
        }
        if (command.MoveCall.module !== "zk_bag") {
          return false;
        }
        const fn = command.MoveCall.function;
        if (fn !== "init_claim" && fn !== "reclaim" && fn !== "claim" && fn !== "finalize") {
          return false;
        }
        break;
      default:
        return false;
    }
  }
  return transfers === 1;
}
function getAssetsFromTransaction({
  transaction,
  address,
  isSent
}) {
  const normalizedAddress = (0, import_utils.normalizeSuiAddress)(address);
  const balances = [];
  const nfts = [];
  const coins = [];
  transaction.balanceChanges?.forEach((change) => {
    const validAmountChange = isSent ? BigInt(change.amount) < 0n : BigInt(change.amount) > 0n;
    if (validAmountChange && isOwner(change.owner, normalizedAddress)) {
      balances.push({
        coinType: (0, import_utils.normalizeStructTag)(change.coinType),
        amount: BigInt(change.amount)
      });
    }
  });
  transaction.objectChanges?.forEach((change) => {
    if (!isObjectOwner(change, normalizedAddress, isSent)) {
      return;
    }
    if ("objectType" in change) {
      const type = (0, import_utils.parseStructTag)(change.objectType);
      if (type.address === (0, import_utils.normalizeSuiAddress)("0x2") && type.module === "coin" && type.name === "Coin") {
        if (change.type === "created" || change.type === "transferred" || change.type === "mutated") {
          coins.push({
            ...change,
            type: change.objectType
          });
        }
        return;
      }
    }
    if (isObjectOwner(change, normalizedAddress, isSent) && (change.type === "created" || change.type === "transferred" || change.type === "mutated")) {
      nfts.push({
        objectId: change.objectId,
        type: change.objectType,
        version: change.version,
        digest: change.digest
      });
    }
  });
  return {
    balances,
    nfts,
    coins
  };
}
function getObjectOwnerFromObjectChange(objectChange, isSent) {
  if (isSent) {
    return "owner" in objectChange ? objectChange.owner : null;
  }
  return "recipient" in objectChange ? objectChange.recipient : null;
}
function isObjectOwner(objectChange, address, isSent) {
  const owner = getObjectOwnerFromObjectChange(objectChange, isSent);
  if (isSent) {
    return owner && typeof owner === "object" && "AddressOwner" in owner;
  }
  return ownedAfterChange(objectChange, address);
}
function ownedAfterChange(objectChange, address) {
  if (objectChange.type === "transferred" && isOwner(objectChange.recipient, address)) {
    return true;
  }
  if ((objectChange.type === "created" || objectChange.type === "mutated") && isOwner(objectChange.owner, address)) {
    return true;
  }
  return false;
}
function isOwner(owner, address) {
  return owner && typeof owner === "object" && "AddressOwner" in owner && (0, import_utils.normalizeSuiAddress)(owner.AddressOwner) === address;
}
//# sourceMappingURL=utils.js.map

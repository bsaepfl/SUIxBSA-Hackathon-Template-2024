var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _host, _path, _client, _redirect, _coinsByType, _contract, _ZkSendLinkBuilder_instances, objectsToTransfer_fn, createSendTransactionWithoutContract_fn, estimateClaimGasFee_fn, getCoinsByType_fn;
import { getFullnodeUrl, SuiClient } from "@mysten/sui/client";
import { decodeSuiPrivateKey } from "@mysten/sui/cryptography";
import { Ed25519Keypair } from "@mysten/sui/keypairs/ed25519";
import { Transaction } from "@mysten/sui/transactions";
import { normalizeStructTag, normalizeSuiAddress, SUI_TYPE_ARG, toBase64 } from "@mysten/sui/utils";
import { getContractIds, ZkBag } from "./zk-bag.js";
const DEFAULT_ZK_SEND_LINK_OPTIONS = {
  host: "https://zksend.com",
  path: "/claim",
  network: "mainnet"
};
const SUI_COIN_TYPE = normalizeStructTag(SUI_TYPE_ARG);
const _ZkSendLinkBuilder = class _ZkSendLinkBuilder {
  constructor({
    host = DEFAULT_ZK_SEND_LINK_OPTIONS.host,
    path = DEFAULT_ZK_SEND_LINK_OPTIONS.path,
    keypair = new Ed25519Keypair(),
    network = DEFAULT_ZK_SEND_LINK_OPTIONS.network,
    client = new SuiClient({ url: getFullnodeUrl(network) }),
    sender,
    redirect,
    contract = getContractIds(network)
  }) {
    __privateAdd(this, _ZkSendLinkBuilder_instances);
    this.objectIds = /* @__PURE__ */ new Set();
    this.objectRefs = [];
    this.balances = /* @__PURE__ */ new Map();
    __privateAdd(this, _host);
    __privateAdd(this, _path);
    __privateAdd(this, _client);
    __privateAdd(this, _redirect);
    __privateAdd(this, _coinsByType, /* @__PURE__ */ new Map());
    __privateAdd(this, _contract);
    __privateSet(this, _host, host);
    __privateSet(this, _path, path);
    __privateSet(this, _redirect, redirect);
    this.keypair = keypair;
    __privateSet(this, _client, client);
    this.sender = normalizeSuiAddress(sender);
    this.network = network;
    if (contract) {
      __privateSet(this, _contract, new ZkBag(contract.packageId, contract));
    }
  }
  addClaimableMist(amount) {
    this.addClaimableBalance(SUI_COIN_TYPE, amount);
  }
  addClaimableBalance(coinType, amount) {
    const normalizedType = normalizeStructTag(coinType);
    this.balances.set(normalizedType, (this.balances.get(normalizedType) ?? 0n) + amount);
  }
  addClaimableObject(id) {
    this.objectIds.add(id);
  }
  addClaimableObjectRef(ref, type) {
    this.objectRefs.push({ ref, type });
  }
  getLink() {
    const link = new URL(__privateGet(this, _host));
    link.pathname = __privateGet(this, _path);
    link.hash = `${__privateGet(this, _contract) ? "$" : ""}${toBase64(
      decodeSuiPrivateKey(this.keypair.getSecretKey()).secretKey
    )}`;
    if (this.network !== "mainnet") {
      link.searchParams.set("network", this.network);
    }
    if (__privateGet(this, _redirect)) {
      link.searchParams.set("redirect_url", __privateGet(this, _redirect).url);
      if (__privateGet(this, _redirect).name) {
        link.searchParams.set("name", __privateGet(this, _redirect).name);
      }
    }
    return link.toString();
  }
  async create({
    signer,
    ...options
  }) {
    const tx = await this.createSendTransaction(options);
    const result = await __privateGet(this, _client).signAndExecuteTransaction({
      transaction: await tx.build({ client: __privateGet(this, _client) }),
      signer,
      options: {
        showEffects: true
      }
    });
    if (result.effects?.status.status !== "success") {
      throw new Error(`Transaction failed: ${result.effects?.status.error ?? "Unknown error"}`);
    }
    if (options.waitForTransaction) {
      await __privateGet(this, _client).waitForTransaction({ digest: result.digest });
    }
    return result;
  }
  async createSendTransaction({
    transaction = new Transaction(),
    calculateGas
  } = {}) {
    if (!__privateGet(this, _contract)) {
      return __privateMethod(this, _ZkSendLinkBuilder_instances, createSendTransactionWithoutContract_fn).call(this, { transaction, calculateGas });
    }
    transaction.setSenderIfNotSet(this.sender);
    return _ZkSendLinkBuilder.createLinks({
      transaction,
      client: __privateGet(this, _client),
      contract: __privateGet(this, _contract).ids,
      links: [this]
    });
  }
  async createSendToAddressTransaction({
    transaction = new Transaction(),
    address
  }) {
    const objectsToTransfer = (await __privateMethod(this, _ZkSendLinkBuilder_instances, objectsToTransfer_fn).call(this, transaction)).map((obj) => obj.ref);
    transaction.setSenderIfNotSet(this.sender);
    transaction.transferObjects(objectsToTransfer, address);
    return transaction;
  }
  static async createLinks({
    links,
    network = "mainnet",
    client = new SuiClient({ url: getFullnodeUrl(network) }),
    transaction = new Transaction(),
    contract: contractIds = getContractIds(network)
  }) {
    const contract = new ZkBag(contractIds.packageId, contractIds);
    const store = transaction.object(contract.ids.bagStoreId);
    const coinsByType = /* @__PURE__ */ new Map();
    const allIds = links.flatMap((link) => [...link.objectIds]);
    const sender = links[0].sender;
    transaction.setSenderIfNotSet(sender);
    await Promise.all(
      [...new Set(links.flatMap((link) => [...link.balances.keys()]))].map(async (coinType) => {
        const coins = await client.getCoins({
          coinType,
          owner: sender
        });
        coinsByType.set(
          coinType,
          coins.data.filter((coin) => !allIds.includes(coin.coinObjectId))
        );
      })
    );
    const objectRefs = /* @__PURE__ */ new Map();
    const pageSize = 50;
    let offset = 0;
    while (offset < allIds.length) {
      let chunk = allIds.slice(offset, offset + pageSize);
      offset += pageSize;
      const objects = await client.multiGetObjects({
        ids: chunk,
        options: {
          showType: true
        }
      });
      for (const [i, res] of objects.entries()) {
        if (!res.data || res.error) {
          throw new Error(`Failed to load object ${chunk[i]} (${res.error?.code})`);
        }
        objectRefs.set(chunk[i], {
          ref: transaction.objectRef({
            version: res.data.version,
            digest: res.data.digest,
            objectId: res.data.objectId
          }),
          type: res.data.type
        });
      }
    }
    const mergedCoins = /* @__PURE__ */ new Map([
      [SUI_COIN_TYPE, transaction.gas]
    ]);
    for (const [coinType, coins] of coinsByType) {
      if (coinType === SUI_COIN_TYPE) {
        continue;
      }
      const [first, ...rest] = coins.map(
        (coin) => transaction.objectRef({
          objectId: coin.coinObjectId,
          version: coin.version,
          digest: coin.digest
        })
      );
      if (rest.length > 0) {
        transaction.mergeCoins(first, rest);
      }
      mergedCoins.set(coinType, transaction.object(first));
    }
    for (const link of links) {
      const receiver = link.keypair.toSuiAddress();
      transaction.add(contract.new({ arguments: [store, receiver] }));
      link.objectRefs.forEach(({ ref, type }) => {
        transaction.add(
          contract.add({
            arguments: [store, receiver, ref],
            typeArguments: [type]
          })
        );
      });
      link.objectIds.forEach((id) => {
        const object = objectRefs.get(id);
        if (!object) {
          throw new Error(`Object ${id} not found`);
        }
        transaction.add(
          contract.add({
            arguments: [store, receiver, object.ref],
            typeArguments: [object.type]
          })
        );
      });
    }
    for (const [coinType, merged] of mergedCoins) {
      const linksWithCoin = links.filter((link) => link.balances.has(coinType));
      if (linksWithCoin.length === 0) {
        continue;
      }
      const balances = linksWithCoin.map((link) => link.balances.get(coinType));
      const splits = transaction.splitCoins(merged, balances);
      for (const [i, link] of linksWithCoin.entries()) {
        transaction.add(
          contract.add({
            arguments: [store, link.keypair.toSuiAddress(), splits[i]],
            typeArguments: [`0x2::coin::Coin<${coinType}>`]
          })
        );
      }
    }
    return transaction;
  }
};
_host = new WeakMap();
_path = new WeakMap();
_client = new WeakMap();
_redirect = new WeakMap();
_coinsByType = new WeakMap();
_contract = new WeakMap();
_ZkSendLinkBuilder_instances = new WeakSet();
objectsToTransfer_fn = async function(tx) {
  const objectIDs = [...this.objectIds];
  const refsWithType = this.objectRefs.concat(
    (objectIDs.length > 0 ? await __privateGet(this, _client).multiGetObjects({
      ids: objectIDs,
      options: {
        showType: true
      }
    }) : []).map((res, i) => {
      if (!res.data || res.error) {
        throw new Error(`Failed to load object ${objectIDs[i]} (${res.error?.code})`);
      }
      return {
        ref: tx.objectRef({
          version: res.data.version,
          digest: res.data.digest,
          objectId: res.data.objectId
        }),
        type: res.data.type
      };
    })
  );
  for (const [coinType, amount] of this.balances) {
    if (coinType === SUI_COIN_TYPE) {
      const [sui] = tx.splitCoins(tx.gas, [amount]);
      refsWithType.push({
        ref: sui,
        type: `0x2::coin::Coin<${coinType}>`
      });
    } else {
      const coins = (await __privateMethod(this, _ZkSendLinkBuilder_instances, getCoinsByType_fn).call(this, coinType)).map((coin) => coin.coinObjectId);
      if (coins.length > 1) {
        tx.mergeCoins(coins[0], coins.slice(1));
      }
      const [split] = tx.splitCoins(coins[0], [amount]);
      refsWithType.push({
        ref: split,
        type: `0x2::coin::Coin<${coinType}>`
      });
    }
  }
  return refsWithType;
};
createSendTransactionWithoutContract_fn = async function({
  transaction: tx = new Transaction(),
  calculateGas
} = {}) {
  const gasEstimateFromDryRun = await __privateMethod(this, _ZkSendLinkBuilder_instances, estimateClaimGasFee_fn).call(this);
  const baseGasAmount = calculateGas ? await calculateGas({
    balances: this.balances,
    objects: [...this.objectIds],
    gasEstimateFromDryRun
  }) : gasEstimateFromDryRun * 2n;
  const gasWithBuffer = baseGasAmount + 1013n;
  const roundedGasAmount = gasWithBuffer - gasWithBuffer % 1000n - 13n;
  const address = this.keypair.toSuiAddress();
  const objectsToTransfer = (await __privateMethod(this, _ZkSendLinkBuilder_instances, objectsToTransfer_fn).call(this, tx)).map((obj) => obj.ref);
  const [gas] = tx.splitCoins(tx.gas, [roundedGasAmount]);
  objectsToTransfer.push(gas);
  tx.setSenderIfNotSet(this.sender);
  tx.transferObjects(objectsToTransfer, address);
  return tx;
};
estimateClaimGasFee_fn = async function() {
  const tx = new Transaction();
  tx.setSender(this.sender);
  tx.setGasPayment([]);
  tx.transferObjects([tx.gas], this.keypair.toSuiAddress());
  const idsToTransfer = [...this.objectIds];
  for (const [coinType] of this.balances) {
    const coins = await __privateMethod(this, _ZkSendLinkBuilder_instances, getCoinsByType_fn).call(this, coinType);
    if (!coins.length) {
      throw new Error(`Sending account does not contain any coins of type ${coinType}`);
    }
    idsToTransfer.push(coins[0].coinObjectId);
  }
  if (idsToTransfer.length > 0) {
    tx.transferObjects(
      idsToTransfer.map((id) => tx.object(id)),
      this.keypair.toSuiAddress()
    );
  }
  const result = await __privateGet(this, _client).dryRunTransactionBlock({
    transactionBlock: await tx.build({ client: __privateGet(this, _client) })
  });
  return BigInt(result.effects.gasUsed.computationCost) + BigInt(result.effects.gasUsed.storageCost) - BigInt(result.effects.gasUsed.storageRebate);
};
getCoinsByType_fn = async function(coinType) {
  if (__privateGet(this, _coinsByType).has(coinType)) {
    return __privateGet(this, _coinsByType).get(coinType);
  }
  const coins = await __privateGet(this, _client).getCoins({
    coinType,
    owner: this.sender
  });
  __privateGet(this, _coinsByType).set(coinType, coins.data);
  return coins.data;
};
let ZkSendLinkBuilder = _ZkSendLinkBuilder;
export {
  ZkSendLinkBuilder
};
//# sourceMappingURL=builder.js.map
